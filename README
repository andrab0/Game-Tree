Tema proiect: Game Tree
Autor: Andra-Maria Bordincel, 315CC
Durata aproximativa implementare tema: 20 de ore

Pentru implementrea acestei teme am utilizat fisierul auxiliar "tema2.h" in care am salvat structura utilizata pentru constructia abrorelui de joc si antetele functiilor create in fisierul sursa "tema2SD.c". Structura folosita de mine in realizarea temei, definita "Tree", are 3 componente, anume "val", ce reprezinta valoarea matricei nodului respectiv, "copil", care indica copilul nodului, si "frateNod", ce indica primul frate al nodului de pe un anumit nivel.

In functia main am folosit doua variabile de tip FILE, sursa si dest, pentru deschiderea fisierului sursa, din care extrag informatia necesara realizarii arborelui de joc, si deschiderea fisierului destinatie, in care afisez forma finala a arborelui. De asemenea, am initializat cate o variabila de tip char pentru fiecare dintre cei 4 indici ai cerintelor, si inca una de tip char in care copiez indicele cerintei transmise ca si parametru, ( -c1/ -c2/ -c3/ -b), utilizand functia "strcpy". In continuare verific cu ajutorul functiei "strcmp" ce cerinta se vrea a fi rezolvata, utilizand o secventa "if - else - if". Am reusit sa realizez doar prima cerinta a temei, deci prin urmare, in ramura corespondenta apelez functia "createRoot", careia ii transmit ca si parametrii cele doua fisiere deschise anterior.

In functia "createRoot" declar un nod de tip "Tree", care reprezinta radacina arvorelui de joc, o variabila de tip char in care extrag jucatorul de pe pozitia "Max" si o variabila de tip int* ini care salvez cele doua dimensiuni citite din fisierul de intrare. Dupa citirea dimensiunilor, aloc memorie pentru nodul radacina, dar si pentru matricea corespondenta acestuia, apoi initializez copilul si fratele cu valoarea NULL. In continuare citesc matricea din fisierul de intrare, folosind functiile "fscanf" si "getc" pentru a extrage fiecare caracter din componenta sa. 

In functia "genArbore", careia ii transmit ca si parametru un nod, dimensiunile tablei de joc si jucatorul ce urmeaza sa faca mutarea, folosesc doua variabile de tip "Tree" pentru prelucrarea valorilor nodului transmis ca parametru. Pentru inceput, salvez in variabila "p" toate caracteristicile nodului, apoi aloc memorie pentru nodul "temp". Copiez prin functia "copiereMatrice" valoarea matricii nodului "p" in nodul "temp" pentru a evita coruperea nodului transmis ca parametru. Incep apoi o parcurgere a matricei nodului "temp" pe coloane, de la cea mai din stanga, si de jos in sus pentru a identifica unde se afla primul caracter "-" ce trebuie modificat. Variabila semafor "ok", initializata cu valoarea 0, are rolul de a contoriza prima aparitie a unei liniute pe o coloana. In cazul in care "ok" devine 1, s-a gasit prima liniuta de pe o coloana, liniuta ce trebuie modificata. Verific existenta primului copil al acestuia. Daca primul copil al nodului este NULL, se aloca memorie pentru copilul nodului p si pentru matricea corespunzatoare acestuia, in care se copiaza valoarea matricii nodului "temp". Dupa aceasta operatie, tinand cont de faptul ca se cunosc indicii pe care a aparut liniuta, inlocuiesc valoarea elementului ce contine liniuta in matricea lui p->copil cu valoarea jucatorului curent, iar "p" devine p->copil. Verific daca aceasta schimbare determina o situatie de win, iar daca nu, continui generarea noilor noduri ale arborelui, reapeland functia "genArb". Procedez in mod similar si in cazul in care nodul copil nu este null, alocand de aceasta data memorie pentru primul frate si reluand procedeul descris mai sus, anume inlocuirea valorii, trecerea lui p in p->frateNod si verificarea situatiei de win. Daca variabila "ok" are valoarea 0 la finalul parcurgerii inseamna ca s-au epuizat toate posibilitatile de inlocuire a liniutelor de pe o coloana si se continua verificarea urmatoarei coloane. La finalul functiei se elibereaza memoria folosita pentru varabila "temp".

Functia "copiereMatrice" primeste ca si parametrii nodul destinatie, nodul sursa si dimensiunile tablei de joc realizeaza parcurgerea element cu element a celor doua matrici si salveaza valorile din matricea nodului sursa in matricea nodului destinatie.

Functia "printareNod" primeste ca si parametrii fisierul destinatie in care trebuie afisat rezultatul, nodul ce se vrea a fi printat, dimensiunile tablei de joc si numarul de tab-uri ce trebuiesc folosite la afisare, corespondent nivelului de adancime pe care se afla nodul. Inaintea fiecarei matrici afisate se printeaza cate un rand liber, cu exceptia matricii nodului radacina. Se salveaza caracteristicile nodului transmis ca parametru intr-un nod "temp", ce este parcus element cu element. Se verifica existenta elementului respectiv, dupa care se aifiseaza numarul de tab-uri corespunzator adancimii nodului si matricea efectiva. Prin parcurgerea element cu element am intalnit doua posibilitati. Prima posibilitate este cea a unui element aflat pe ultima coloana, caz in care se afiseaza elementul simplu, urmat de caracterul "\n" si o secventa de tab-uri ca si cele afisate mai sus. A doua posibilitate este cea in care elementul se alfa pe restul coloanelor, caz in care este afisata valoarea sa urmata de un caracter de spatiu. In urma afisarii se reapeleaza functia, de data aceasta cu copilul nodului temporar si nivelul de adancime crescut, pentru a epuiza toate posibilitatile fiecarui nod. In urma epuizarii se trece la fratele nodului temporar.

In functiile "verificareWinVerticala", "verificareWinOrizontala", "verificareWinDiagonalaP" si "verificareWinDiagonalaS" folosesc un procedeu similar, anume parcurgerea element cu element a matricii nodului transmis ca parametru si cautarea unei secvente consecutive de 4 elemente cu valoarea "player". Valabil pentru oricare dintre aceste 4 functii, daca rezultatul este 0, inseamna ca pe cazul respectiv nu este o situatie castigatoare, iar daca rezultatul este 1, matricea este un nod terminal al ramurii arborelui deoarece s-a gasit o situatie castigatoare. Toate aceste 4 functii sunt apelate in functia de verificare simultana a celor 4 cazuri, "verificareWIN" ce intoarce ca rezultat 1, daca macar una dintre acestea pune in evidenta o situatie de castig. Functia "verificareWIN", apelata in "genArbore", este cea utilizata pentru verificarea daca adaugarea valorii unui anumit player a determinat o situatie castigatoare sau nu. 

In final, functia "dealocareMem", care primeste ca si parametru nodul pentru care se va elibera memoria si dimensiunile tablei de joc. Se verifica mai intai existenta nodului transmis ca parametru, iar daca acesta exista, se elibereaza memoria ocupata de matricea sa, apoi se reapeleaza recursiv functia pentru nod->frateNod, iar la finalizarea acestei operatii se reapeleaza functia si pentru nod->copil. Am ales aceasta implementare deoarece nodul copil reprezinta legatura directa dintre un nod si fratii copilului, deci memoria utilizata pentru frati sai se va elibera inainte de eliminarea legaturilor.

##PRECIZARI:
	Pentru verificarea de coding-style am folosit script-ul primit in cardul primei Teme. Pe anumite linii din cod, mai exact cele din functia "genArb", am o indentare ce poate insuma 6-7 tab-uri, si desi acestea sunt urmate de un sir de maxim 40-45 de caractere, primesc ca si WARNING-uri depasirea unui numar de 80 de caractere pe linie. De asemenea, primesc si WARNING-uri de genul "Too many leading tabs - consider code refactoring", iar daca renunt la cateva dintre acestea primesc alte WARNING-uri legate de necesitatea acestora. As vrea sa solicit verificarea manula a acestor aspecte legate de coding-style daca se poate. Va multumesc!
